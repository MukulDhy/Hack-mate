========== FILE START ==========
üìÑ File: api.ts
üìè Size: 1042 bytes
========== CODE ==========
// src/services/api.ts
import axios from 'axios';
import { API_URL } from '@/config/API_URL';
// const BASE_URL = process.env.REACT_APP_API_URL || 'https://api.yourcompany.com';
const BASE_URL = API_URL;

export const api = axios.create({
  baseURL: BASE_URL,
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  },
});


// Add request interceptor to include auth token
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Add response interceptor to handle common errors
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.code === 'ECONNABORTED') {
      throw new Error('Request timeout');
    }
    if (!error.response) {
      throw new Error('Network error: Could not connect to server');
    }
    return Promise.reject(error);
  }
);
========== FILE END ==========


========== FILE START ==========
üìÑ File: authService.ts
üìè Size: 2607 bytes
========== CODE ==========
// src/services/authService.ts
import { api } from './api';
import { User } from '../store/slices/authSlice';

interface LoginCredentials {
  email: string;
  password: string;
}

interface RegisterData extends Omit<User, 'id'> {
  password: string;
}

interface AuthResponse {
  user: User;
  token: string;
}

export const authService = {
  async login(credentials: LoginCredentials): Promise<AuthResponse> {
    const response = await api.post('/auth/login', credentials);
    return response.data;
  },

  async register(userData: { name: string; email: string; password: string }) {
    try {
      const response = await api.post('/api/user/register', userData);
      return response.data;
    } catch (error: any) {
      // Extract meaningful error information
      if (error.response?.data) {
        throw {
          message: error.response.data.message,
          errors: error.response.data.errors || null,
          errorCode: error.response.data.errorCode
        };
      } else if (error.request) {
        throw { message: 'Network error: Could not connect to server' };
      } else {
        throw { message: error.message || 'Registration failed' };
      }
    }
  },

  async logout(): Promise<void> {
    await api.post('/api/user/logout');
  },

  async verifyToken(token: string): Promise<AuthResponse> {
     try {
    const response = await api.get('/api/user/verify', {
      headers: {
        Authorization: `Bearer ${token}`
      },
    });
    return response.data;
     } catch (error: any) {
      // Extract meaningful error information
      if (error.response?.data) {
        throw {
          message: error.response.data.message,
          errors: error.response.data.errors || null,
          errorCode: error.response.data.errorCode
        };
      } else if (error.request) {
        throw { message: 'Network error: Could not connect to server' };
      } else {
        throw { message: error.message || 'Verification Token failed' };
      }
    }
  },

  async refreshToken(): Promise<{ token: string }> {
    const response = await api.post('/auth/refresh');
    return response.data;
  },

  async forgotPassword(email: string): Promise<{ message: string }> {
    const response = await api.post('/auth/forgot-password', { email });
    return response.data;
  },

  async resetPassword(token: string, password: string): Promise<{ message: string }> {
    const response = await api.post('/auth/reset-password', { token, password });
    return response.data;
  },
};
========== FILE END ==========


========== FILE START ==========
üìÑ File: userService.ts
üìè Size: 1186 bytes
========== CODE ==========
// src/services/userService.ts
import { api } from './api';

interface UserProfile {
  id: string;
  email: string;
  name: string;
  role: string;
  department: string;
  avatar?: string;
  phone?: string;
  address?: string;
}

export const userService = {
  async getProfile(userId: string): Promise<UserProfile> {
    const response = await api.get(`/users/${userId}`);
    return response.data;
  },

  async updateProfile(userData: Partial<UserProfile>): Promise<UserProfile> {
    const response = await api.put(`/users/${userData.id}`, userData);
    return response.data;
  },

  async getAllUsers(): Promise<UserProfile[]> {
    const response = await api.get('/users');
    return response.data;
  },

  async deleteUser(userId: string): Promise<void> {
    await api.delete(`/users/${userId}`);
  },

  async uploadAvatar(userId: string, file: File): Promise<{ avatarUrl: string }> {
    const formData = new FormData();
    formData.append('avatar', file);
    const response = await api.post(`/users/${userId}/avatar`, formData, {
      headers: { 'Content-Type': 'multipart/form-data' },
    });
    return response.data;
  },
};
========== FILE END ==========


========== FILE START ==========
üìÑ File: websocketService.ts
üìè Size: 6547 bytes
========== CODE ==========
import {API_URL, WS_API_URL} from "../config/API_URL"
class WebSocketService {
  constructor(store) {
    this.store = store;
    this.socket = null;
    this.reconnectInterval = 1000;
    this.maxReconnectInterval = 30000;
    this.reconnectAttempts = 0;
    this.pingInterval = null;
    this.messageQueue = [];
    this.isConnected = false;
  }

  connect(token) {
    if (this.socket?.readyState === WebSocket.OPEN) {
      return;
    }

    try {
      const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
      const wsUrl = `${protocol}//${WS_API_URL}?token=${token}`;
      this.socket = new WebSocket(wsUrl);

      this.setupEventHandlers();
    } catch (error) {
      console.error("WebSocket connection failed:", error);
      this.handleReconnection();
    }
  }

  setupEventHandlers() {
    this.socket.onopen = () => {
      console.log("WebSocket connected");
      this.isConnected = true;
      this.reconnectAttempts = 0;
      this.store.dispatch({
        type: "websocket/setConnectionStatus",
        payload: true,
      });

      // Process any queued messages
      this.processMessageQueue();

      // Start heartbeat
      this.startHeartbeat();
    };

    this.socket.onclose = (event) => {
      console.log("WebSocket disconnected", event.code, event.reason);
      this.isConnected = false;
      this.store.dispatch({
        type: "websocket/setConnectionStatus",
        payload: false,
      });
      this.stopHeartbeat();
      this.handleReconnection();
    };

    this.socket.onerror = (error) => {
      console.error("WebSocket error:", error);
      this.store.dispatch({
        type: "websocket/setError",
        payload: error.message,
      });
    };

    this.socket.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data);
        this.handleIncomingMessage(message);
      } catch (error) {
        console.error("Error parsing WebSocket message:", error);
      }
    };
  }

  handleIncomingMessage(message) {
    const { type, ...payload } = message;

    switch (type) {
      case "connection.established":
        this.store.dispatch({
          type: "websocket/connectionEstablished",
          payload,
        });
        break;

      case "team.message":
        this.store.dispatch({ type: "websocket/teamMessage", payload });
        break;

      case "team.typing":
        this.store.dispatch({ type: "websocket/typingIndicator", payload });
        break;

      case "notifications.unread":
        this.store.dispatch({ type: "websocket/unreadNotifications", payload });
        break;

      case "notification":
        this.store.dispatch({ type: "websocket/newNotification", payload });
        break;

      case "notifications.marked_read":
        this.store.dispatch({ type: "websocket/notificationsRead", payload });
        break;

      case "presence.update":
        this.store.dispatch({ type: "websocket/presenceUpdate", payload });
        break;

      case "hackathon.timer":
        this.store.dispatch({ type: "websocket/hackathonTimer", payload });
        break;

      case "hackathon.subscribed":
        this.store.dispatch({ type: "websocket/hackathonSubscribed", payload });
        break;

      case "hackathon.started":
        this.store.dispatch({ type: "websocket/hackathonStarted", payload });
        break;

      case "hackathon.ended":
        this.store.dispatch({ type: "websocket/hackathonEnded", payload });
        break;

      case "team.created":
        this.store.dispatch({ type: "websocket/teamCreated", payload });
        break;

      case "team.updated":
        this.store.dispatch({ type: "websocket/teamUpdated", payload });
        break;

      case "error":
        this.store.dispatch({ type: "websocket/error", payload });
        break;

      default:
        console.warn("Unhandled WebSocket message type:", type);
    }
  }

  sendMessage(message) {
    if (this.isConnected && this.socket?.readyState === WebSocket.OPEN) {
      this.socket.send(JSON.stringify(message));
    } else {
      // Queue message for later delivery
      this.messageQueue.push(message);
    }
  }

  processMessageQueue() {
    while (this.messageQueue.length > 0) {
      const message = this.messageQueue.shift();
      this.sendMessage(message);
    }
  }

  startHeartbeat() {
    this.pingInterval = setInterval(() => {
      if (this.isConnected) {
        this.sendMessage({ type: "presence.ping" });
      }
    }, 25000); // Send ping every 25 seconds
  }

  stopHeartbeat() {
    if (this.pingInterval) {
      clearInterval(this.pingInterval);
      this.pingInterval = null;
    }
  }

  handleReconnection() {
    const token = this.store.getState().auth?.token;

    if (token && this.reconnectAttempts < 10) {
      const delay = Math.min(
        this.reconnectInterval * Math.pow(1.5, this.reconnectAttempts),
        this.maxReconnectInterval
      );

      setTimeout(() => {
        this.reconnectAttempts++;
        this.connect(token);
      }, delay);
    }
  }

  disconnect() {
    this.stopHeartbeat();
    this.isConnected = false;
    this.reconnectAttempts = 0;

    if (this.socket) {
      this.socket.close(1000, "User initiated disconnect");
      this.socket = null;
    }

    this.store.dispatch({
      type: "websocket/setConnectionStatus",
      payload: false,
    });
  }

  // Specific message sending methods
  sendTeamMessage(teamId, text) {
    this.sendMessage({
      type: "team.sendMessage",
      teamId,
      text,
    });
  }

  sendTypingIndicator(teamId, isTyping) {
    this.sendMessage({
      type: "team.typing",
      teamId,
      isTyping,
    });
  }

  markNotificationsRead(notificationIds) {
    this.sendMessage({
      type: "notifications.markRead",
      notificationIds,
    });
  }

  subscribeToHackathon(hackathonId) {
    this.sendMessage({
      type: "hackathon.subscribe",
      hackathonId,
    });
  }
}

// Singleton instance
let webSocketServiceInstance = null;

export const getWebSocketService = (store) => {
  if (!webSocketServiceInstance) {
    webSocketServiceInstance = new WebSocketService(store);
  }
  return webSocketServiceInstance;
};

export const initWebSocketService = (store) => {
  return getWebSocketService(store);
};

========== FILE END ==========


