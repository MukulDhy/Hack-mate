========== FILE START ==========
📄 File: hooks.ts
📏 Size: 777 bytes
========== CODE ==========

// src/store/hooks.ts
import { useDispatch, useSelector, TypedUseSelectorHook } from 'react-redux';
import { RootState, AppDispatch } from './index';

// Use throughout your app instead of plain `useDispatch` and `useSelector`
export const useAppDispatch = () => useDispatch<AppDispatch>();
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;

// Custom hooks for common operations
export const useAuth = () => {
  const dispatch = useAppDispatch();
  const auth = useAppSelector((state) => state.auth);
  
  return {
    ...auth,
    dispatch,
  };
};

export const useUser = () => {
  const dispatch = useAppDispatch();
  const user = useAppSelector((state) => state.auth);
  
  return {
    ...user,
    dispatch,
  };
};
========== FILE END ==========


========== FILE START ==========
📄 File: index.ts
📏 Size: 889 bytes
========== CODE ==========
// src/store/index.ts
import { configureStore } from '@reduxjs/toolkit';
import authReducer from './slices/authSlice';
import userReducer from './slices/userSlice';
import webSocketReducer from './slices/websocketSlice'
import { initWebSocketService } from '../service/websocketService';
export const store = configureStore({
  reducer: {
    auth: authReducer,
    websocket: webSocketReducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: ['persist/PERSIST','websocket/presenceUpdate', 'websocket/typingIndicator'],
         ignoredPaths: ['websocket.onlineUsers', 'websocket.typingIndicators'],
      },
    }),
});


export const webSocketService = initWebSocketService(store);
export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
========== FILE END ==========


========== FILE START ==========
📄 File: slices\authSlice.ts
📏 Size: 6597 bytes
========== CODE ==========
// src/store/slices/authSlice.ts
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { authService } from "../../service/authService";
import { showWarning } from '@/components/ui/ToasterMsg';

export interface User {
  email: string;
  name: string;
}

export interface ErrorValidate {
  field?: string;
  message: string;
}

interface AuthState {
  user: User | null;
  token: string | null;
  isLoading: boolean;
  error: ErrorValidate[] | null;
  message: string | null;
  isAuthenticated: boolean;
  success : number;
  isTokenVerified: boolean; // Add this flag to track token verification status
}

const initialState: AuthState = {
  user: null,
  token: localStorage.getItem('token'),
  isLoading: false,
  error: null,
  success:-1,
  message: null,
  isAuthenticated: false,
  isTokenVerified: false, // Initialize as false
};

// Async thunks
export const loginUser = createAsyncThunk(
  'auth/login',
  async (credentials: { email: string; password: string }, { rejectWithValue }) => {
    try {
      const response = await authService.login(credentials);
      localStorage.setItem('token', response.token);
      return response;
    } catch (error: any) {
      return rejectWithValue(error.response?.data || error.message || 'Login failed');
    }
  }
);

export const registerUser = createAsyncThunk(
  'auth/register',
  async (userData: { name: string; email: string; password: string }, { rejectWithValue }) => {
    try {
      const response = await authService.register(userData);
      
      localStorage.setItem('token', response.data.token);
      return response.data;
    } catch (error: any) {
      console.log("Registration error:", error);
      // Return structured error information
      return rejectWithValue({
        message: error.message || 'Registration failed',
        errors: error.errors || null,
        errorCode: error.errorCode
      });
    }
  }
);

export const logoutUser = createAsyncThunk(
  'auth/logout',
  async (_, { rejectWithValue }) => {
    try {
      await authService.logout();
      localStorage.removeItem('token');
      return null;
    } catch (error: any) {
      return rejectWithValue(error.message || 'Logout failed');
    }
  }
);

export const verifyToken = createAsyncThunk(
  'auth/verifyToken',
  async (_, { rejectWithValue }) => {
    try {
      const token = localStorage.getItem("token");
      if (!token){
       // showWarning("No Token Found","Please Login/Sign Up",4000);
        throw new Error('No token found');
      } 
      const response = await authService.verifyToken(token);
      return response;
    } catch (error: any) {
      //localStorage.removeItem('token');
      return rejectWithValue(error.message || 'Token verification failed');
    }
  }
);
 
  const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    clearError: (state) => {
      state.error = null;
      state.message = null;
    },
    updateUser: (state, action: PayloadAction<Partial<User>>) => {
      if (state.user) {
        state.user = { ...state.user, ...action.payload };
      }
    },
    // Add a reducer to mark token as verified
    setTokenVerified: (state) => {
      state.isTokenVerified = true;
    },
  },
  extraReducers: (builder) => {
    // Login
    builder
      .addCase(loginUser.pending, (state) => {
        state.isLoading = true;
        state.error = null;
        state.message = null;
      })
      .addCase(loginUser.fulfilled, (state, action) => {
        state.isLoading = false;
        state.user = action.payload.user;
        state.token = action.payload.token;
        state.isAuthenticated = true;
        state.isTokenVerified = true; // Mark as verified
        state.error = null;
        state.message = null;
      })
      .addCase(loginUser.rejected, (state, action) => {
        state.isLoading = false;
        state.message = action.payload?.message || null;
        state.error = action.payload?.errors || null;
        state.isAuthenticated = false;
        state.isTokenVerified = true; // Mark as verified even on failure
      });

    // Register
    builder
      .addCase(registerUser.pending, (state) => {
        state.isLoading = true;
        state.error = null;
        state.message = null;
      })
      .addCase(registerUser.fulfilled, (state, action) => {
        state.isLoading = false;
        state.user = action.payload.user || null;
        state.token = action.payload.token || null;
        state.isAuthenticated = true;
        state.isTokenVerified = true; // Mark as verified
        state.error = null;
        state.message = null;
        state.success = action.payload.success || -1;
      })
      .addCase(registerUser.rejected, (state, action) => {
        state.isLoading = false;
        state.message = action.payload?.message || null;
        state.error = action.payload?.errors || [
          { message: action.payload?.message || 'Registration failed' }
        ];
        state.isAuthenticated = false;
        state.isTokenVerified = true;
        state.success = 0;
      });

    // Logout
    builder
      .addCase(logoutUser.fulfilled, (state) => {
        state.user = null;
        state.token = null;
        state.isAuthenticated = false;
        state.isTokenVerified = true; // Mark as verified
        state.error = null;
        state.message = null;
      });

    // Token verification
    builder
      .addCase(verifyToken.pending, (state) => {
        state.isLoading = true;
      })
      .addCase(verifyToken.fulfilled, (state, action) => {
        state.isLoading = false;
        state.user = action.payload.data.user || null;
        state.isAuthenticated = true;
        state.isTokenVerified = true; // Mark as verified
        state.error = null;
        state.message = action.payload.message || "";
        state.success =action.payload?.success ? 1 : -1;
      })
      .addCase(verifyToken.rejected, (state) => {
        state.isLoading = false;
        state.user = null;
        state.token = null;
        state.isAuthenticated = false;
        state.isTokenVerified = true; // Mark as verified
        state.error = null;
        state.success =  -1;
        state.message = null;
      });
  },
});

export const { clearError, updateUser, setTokenVerified } = authSlice.actions;
export default authSlice.reducer;
========== FILE END ==========


========== FILE START ==========
📄 File: slices\userSlice.ts
📏 Size: 2799 bytes
========== CODE ==========
// src/store/slices/userSlice.ts
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { userService } from '../../service/userService';

interface UserProfile {
  id: string;
  email: string;
  name: string;
  role: string;
  department: string;
  avatar?: string;
  phone?: string;
  address?: string;
}

interface UserState {
  profile: UserProfile | null;
  users: UserProfile[];
  isLoading: boolean;
  error: string | null;
}

const initialState: UserState = {
  profile: null,
  users: [],
  isLoading: false,
  error: null,
};

export const fetchUserProfile = createAsyncThunk(
  'user/fetchProfile',
  async (userId: string, { rejectWithValue }) => {
    try {
      const response = await userService.getProfile(userId);
      return response;
    } catch (error: any) {
      return rejectWithValue(error.message);
    }
  }
);

export const updateUserProfile = createAsyncThunk(
  'user/updateProfile',
  async (userData: Partial<UserProfile>, { rejectWithValue }) => {
    try {
      const response = await userService.updateProfile(userData);
      return response;
    } catch (error: any) {
      return rejectWithValue(error.message);
    }
  }
);

export const fetchAllUsers = createAsyncThunk(
  'user/fetchAllUsers',
  async (_, { rejectWithValue }) => {
    try {
      const response = await userService.getAllUsers();
      return response;
    } catch (error: any) {
      return rejectWithValue(error.message);
    }
  }
);

const userSlice = createSlice({
  name: 'user',
  initialState,
  reducers: {
    clearUserError: (state) => {
      state.error = null;
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchUserProfile.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(fetchUserProfile.fulfilled, (state, action) => {
        state.isLoading = false;
        state.profile = action.payload;
      })
      .addCase(fetchUserProfile.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })
      .addCase(updateUserProfile.fulfilled, (state, action) => {
        state.profile = action.payload;
      })
      .addCase(fetchAllUsers.pending, (state) => {
        state.isLoading = true;
      })
      .addCase(fetchAllUsers.fulfilled, (state, action) => {
        state.isLoading = false;
        state.users = action.payload;
      })
      .addCase(fetchAllUsers.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      });
  },
});

export const { clearUserError } = userSlice.actions;
export default userSlice.reducer;
========== FILE END ==========


========== FILE START ==========
📄 File: slices\websocketSlice.ts
📏 Size: 5542 bytes
========== CODE ==========
// src/store/slices/websocketSlice.js
import { createSlice } from "@reduxjs/toolkit";

const initialState = {
  isConnected: false,
  error: null,
  notifications: [],
  teamMessages: {},
  typingIndicators: {},
  onlineUsers: {},
  hackathonTimers: {},
  subscribedHackathons: {},
  lastActivity: null,
};

// Helper function to safely update nested state
const updateTeamMessages = (state, teamId, message) => {
  if (!state.teamMessages[teamId]) {
    state.teamMessages[teamId] = [];
  }

  // Keep only the last 100 messages per team to prevent memory issues
  if (state.teamMessages[teamId].length >= 100) {
    state.teamMessages[teamId].shift();
  }

  state.teamMessages[teamId].push(message);
};

const websocketSlice = createSlice({
  name: "websocket",
  initialState,
  reducers: {
    setConnectionStatus: (state, action) => {
      state.isConnected = action.payload;
      if (action.payload) {
        state.error = null;
      }
      state.lastActivity = new Date().toISOString();
    },
    setError: (state, action) => {
      state.error = action.payload;
      state.lastActivity = new Date().toISOString();
    },
    connectionEstablished: (state) => {
      state.isConnected = true;
      state.error = null;
      state.lastActivity = new Date().toISOString();
    },
    teamMessage: (state, action) => {
      const { teamId, message } = action.payload;
      updateTeamMessages(state, teamId, message);
      state.lastActivity = new Date().toISOString();
    },
    typingIndicator: (state, action) => {
      const { teamId, userId, isTyping, timestamp } = action.payload;

      if (!state.typingIndicators[teamId]) {
        state.typingIndicators[teamId] = {};
      }

      if (isTyping) {
        state.typingIndicators[teamId][userId] = timestamp;
      } else {
        delete state.typingIndicators[teamId][userId];
      }
      state.lastActivity = new Date().toISOString();
    },
    unreadNotifications: (state, action) => {
      state.notifications = action.payload.notifications;
      state.lastActivity = new Date().toISOString();
    },
    newNotification: (state, action) => {
      // Add new notification to the beginning of the array
      state.notifications.unshift(action.payload.notification);

      // Keep only the last 50 notifications
      if (state.notifications.length > 50) {
        state.notifications.pop();
      }
      state.lastActivity = new Date().toISOString();
    },
    notificationsRead: (state, action) => {
      const { notificationIds } = action.payload;
      state.notifications = state.notifications.map((notification) =>
        notificationIds.includes(notification.id)
          ? { ...notification, read: true }
          : notification
      );
      state.lastActivity = new Date().toISOString();
    },
    presenceUpdate: (state, action) => {
      const { userId, lastSeen, teamId } = action.payload;

      if (!state.onlineUsers[teamId]) {
        state.onlineUsers[teamId] = {};
      }

      state.onlineUsers[teamId][userId] = lastSeen;
      state.lastActivity = new Date().toISOString();
    },
    hackathonTimer: (state, action) => {
      const { hackathonId, ...timerData } = action.payload;
      state.hackathonTimers[hackathonId] = {
        ...timerData,
        lastUpdated: new Date().toISOString(),
      };
      state.lastActivity = new Date().toISOString();
    },
    hackathonSubscribed: (state, action) => {
      const { hackathonId } = action.payload;
      state.subscribedHackathons[hackathonId] = true;
      state.lastActivity = new Date().toISOString();
    },
    hackathonStarted: (state, action) => {
      const { hackathonId, timestamp } = action.payload;
      if (state.hackathonTimers[hackathonId]) {
        state.hackathonTimers[hackathonId].status = "running";
        state.hackathonTimers[hackathonId].hasStarted = true;
      }
      state.lastActivity = new Date().toISOString();
    },
    hackathonEnded: (state, action) => {
      const { hackathonId, timestamp } = action.payload;
      if (state.hackathonTimers[hackathonId]) {
        state.hackathonTimers[hackathonId].status = "ended";
        state.hackathonTimers[hackathonId].remainingMs = 0;
      }
      state.lastActivity = new Date().toISOString();
    },
    teamCreated: (state, action) => {
      // Handle team created event
      state.lastActivity = new Date().toISOString();
    },
    teamUpdated: (state, action) => {
      // Handle team updated event
      state.lastActivity = new Date().toISOString();
    },
    clearMessages: (state, action) => {
      const { teamId } = action.payload;
      if (teamId && state.teamMessages[teamId]) {
        state.teamMessages[teamId] = [];
      }
      state.lastActivity = new Date().toISOString();
    },
    clearError: (state) => {
      state.error = null;
      state.lastActivity = new Date().toISOString();
    },
    resetWebSocketState: () => initialState,
  },
});

export const {
  setConnectionStatus,
  setError,
  connectionEstablished,
  teamMessage,
  typingIndicator,
  unreadNotifications,
  newNotification,
  notificationsRead,
  presenceUpdate,
  hackathonTimer,
  hackathonSubscribed,
  hackathonStarted,
  hackathonEnded,
  teamCreated,
  teamUpdated,
  clearMessages,
  clearError,
  resetWebSocketState,
} = websocketSlice.actions;

export default websocketSlice.reducer;

========== FILE END ==========


========== FILE START ==========
📄 File: api.ts
📏 Size: 1042 bytes
========== CODE ==========
// src/services/api.ts
import axios from 'axios';
import { API_URL } from '@/config/API_URL';
// const BASE_URL = process.env.REACT_APP_API_URL || 'https://api.yourcompany.com';
const BASE_URL = API_URL;

export const api = axios.create({
  baseURL: BASE_URL,
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  },
});


// Add request interceptor to include auth token
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Add response interceptor to handle common errors
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.code === 'ECONNABORTED') {
      throw new Error('Request timeout');
    }
    if (!error.response) {
      throw new Error('Network error: Could not connect to server');
    }
    return Promise.reject(error);
  }
);
========== FILE END ==========


========== FILE START ==========
📄 File: authService.ts
📏 Size: 2607 bytes
========== CODE ==========
// src/services/authService.ts
import { api } from './api';
import { User } from '../store/slices/authSlice';

interface LoginCredentials {
  email: string;
  password: string;
}

interface RegisterData extends Omit<User, 'id'> {
  password: string;
}

interface AuthResponse {
  user: User;
  token: string;
}

export const authService = {
  async login(credentials: LoginCredentials): Promise<AuthResponse> {
    const response = await api.post('/auth/login', credentials);
    return response.data;
  },

  async register(userData: { name: string; email: string; password: string }) {
    try {
      const response = await api.post('/api/user/register', userData);
      return response.data;
    } catch (error: any) {
      // Extract meaningful error information
      if (error.response?.data) {
        throw {
          message: error.response.data.message,
          errors: error.response.data.errors || null,
          errorCode: error.response.data.errorCode
        };
      } else if (error.request) {
        throw { message: 'Network error: Could not connect to server' };
      } else {
        throw { message: error.message || 'Registration failed' };
      }
    }
  },

  async logout(): Promise<void> {
    await api.post('/api/user/logout');
  },

  async verifyToken(token: string): Promise<AuthResponse> {
     try {
    const response = await api.get('/api/user/verify', {
      headers: {
        Authorization: `Bearer ${token}`
      },
    });
    return response.data;
     } catch (error: any) {
      // Extract meaningful error information
      if (error.response?.data) {
        throw {
          message: error.response.data.message,
          errors: error.response.data.errors || null,
          errorCode: error.response.data.errorCode
        };
      } else if (error.request) {
        throw { message: 'Network error: Could not connect to server' };
      } else {
        throw { message: error.message || 'Verification Token failed' };
      }
    }
  },

  async refreshToken(): Promise<{ token: string }> {
    const response = await api.post('/auth/refresh');
    return response.data;
  },

  async forgotPassword(email: string): Promise<{ message: string }> {
    const response = await api.post('/auth/forgot-password', { email });
    return response.data;
  },

  async resetPassword(token: string, password: string): Promise<{ message: string }> {
    const response = await api.post('/auth/reset-password', { token, password });
    return response.data;
  },
};
========== FILE END ==========


========== FILE START ==========
📄 File: userService.ts
📏 Size: 1186 bytes
========== CODE ==========
// src/services/userService.ts
import { api } from './api';

interface UserProfile {
  id: string;
  email: string;
  name: string;
  role: string;
  department: string;
  avatar?: string;
  phone?: string;
  address?: string;
}

export const userService = {
  async getProfile(userId: string): Promise<UserProfile> {
    const response = await api.get(`/users/${userId}`);
    return response.data;
  },

  async updateProfile(userData: Partial<UserProfile>): Promise<UserProfile> {
    const response = await api.put(`/users/${userData.id}`, userData);
    return response.data;
  },

  async getAllUsers(): Promise<UserProfile[]> {
    const response = await api.get('/users');
    return response.data;
  },

  async deleteUser(userId: string): Promise<void> {
    await api.delete(`/users/${userId}`);
  },

  async uploadAvatar(userId: string, file: File): Promise<{ avatarUrl: string }> {
    const formData = new FormData();
    formData.append('avatar', file);
    const response = await api.post(`/users/${userId}/avatar`, formData, {
      headers: { 'Content-Type': 'multipart/form-data' },
    });
    return response.data;
  },
};
========== FILE END ==========


========== FILE START ==========
📄 File: websocketService.ts
📏 Size: 6547 bytes
========== CODE ==========
import {API_URL, WS_API_URL} from "../config/API_URL"
class WebSocketService {
  constructor(store) {
    this.store = store;
    this.socket = null;
    this.reconnectInterval = 1000;
    this.maxReconnectInterval = 30000;
    this.reconnectAttempts = 0;
    this.pingInterval = null;
    this.messageQueue = [];
    this.isConnected = false;
  }

  connect(token) {
    if (this.socket?.readyState === WebSocket.OPEN) {
      return;
    }

    try {
      const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
      const wsUrl = `${protocol}//${WS_API_URL}?token=${token}`;
      this.socket = new WebSocket(wsUrl);

      this.setupEventHandlers();
    } catch (error) {
      console.error("WebSocket connection failed:", error);
      this.handleReconnection();
    }
  }

  setupEventHandlers() {
    this.socket.onopen = () => {
      console.log("WebSocket connected");
      this.isConnected = true;
      this.reconnectAttempts = 0;
      this.store.dispatch({
        type: "websocket/setConnectionStatus",
        payload: true,
      });

      // Process any queued messages
      this.processMessageQueue();

      // Start heartbeat
      this.startHeartbeat();
    };

    this.socket.onclose = (event) => {
      console.log("WebSocket disconnected", event.code, event.reason);
      this.isConnected = false;
      this.store.dispatch({
        type: "websocket/setConnectionStatus",
        payload: false,
      });
      this.stopHeartbeat();
      this.handleReconnection();
    };

    this.socket.onerror = (error) => {
      console.error("WebSocket error:", error);
      this.store.dispatch({
        type: "websocket/setError",
        payload: error.message,
      });
    };

    this.socket.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data);
        this.handleIncomingMessage(message);
      } catch (error) {
        console.error("Error parsing WebSocket message:", error);
      }
    };
  }

  handleIncomingMessage(message) {
    const { type, ...payload } = message;

    switch (type) {
      case "connection.established":
        this.store.dispatch({
          type: "websocket/connectionEstablished",
          payload,
        });
        break;

      case "team.message":
        this.store.dispatch({ type: "websocket/teamMessage", payload });
        break;

      case "team.typing":
        this.store.dispatch({ type: "websocket/typingIndicator", payload });
        break;

      case "notifications.unread":
        this.store.dispatch({ type: "websocket/unreadNotifications", payload });
        break;

      case "notification":
        this.store.dispatch({ type: "websocket/newNotification", payload });
        break;

      case "notifications.marked_read":
        this.store.dispatch({ type: "websocket/notificationsRead", payload });
        break;

      case "presence.update":
        this.store.dispatch({ type: "websocket/presenceUpdate", payload });
        break;

      case "hackathon.timer":
        this.store.dispatch({ type: "websocket/hackathonTimer", payload });
        break;

      case "hackathon.subscribed":
        this.store.dispatch({ type: "websocket/hackathonSubscribed", payload });
        break;

      case "hackathon.started":
        this.store.dispatch({ type: "websocket/hackathonStarted", payload });
        break;

      case "hackathon.ended":
        this.store.dispatch({ type: "websocket/hackathonEnded", payload });
        break;

      case "team.created":
        this.store.dispatch({ type: "websocket/teamCreated", payload });
        break;

      case "team.updated":
        this.store.dispatch({ type: "websocket/teamUpdated", payload });
        break;

      case "error":
        this.store.dispatch({ type: "websocket/error", payload });
        break;

      default:
        console.warn("Unhandled WebSocket message type:", type);
    }
  }

  sendMessage(message) {
    if (this.isConnected && this.socket?.readyState === WebSocket.OPEN) {
      this.socket.send(JSON.stringify(message));
    } else {
      // Queue message for later delivery
      this.messageQueue.push(message);
    }
  }

  processMessageQueue() {
    while (this.messageQueue.length > 0) {
      const message = this.messageQueue.shift();
      this.sendMessage(message);
    }
  }

  startHeartbeat() {
    this.pingInterval = setInterval(() => {
      if (this.isConnected) {
        this.sendMessage({ type: "presence.ping" });
      }
    }, 25000); // Send ping every 25 seconds
  }

  stopHeartbeat() {
    if (this.pingInterval) {
      clearInterval(this.pingInterval);
      this.pingInterval = null;
    }
  }

  handleReconnection() {
    const token = this.store.getState().auth?.token;

    if (token && this.reconnectAttempts < 10) {
      const delay = Math.min(
        this.reconnectInterval * Math.pow(1.5, this.reconnectAttempts),
        this.maxReconnectInterval
      );

      setTimeout(() => {
        this.reconnectAttempts++;
        this.connect(token);
      }, delay);
    }
  }

  disconnect() {
    this.stopHeartbeat();
    this.isConnected = false;
    this.reconnectAttempts = 0;

    if (this.socket) {
      this.socket.close(1000, "User initiated disconnect");
      this.socket = null;
    }

    this.store.dispatch({
      type: "websocket/setConnectionStatus",
      payload: false,
    });
  }

  // Specific message sending methods
  sendTeamMessage(teamId, text) {
    this.sendMessage({
      type: "team.sendMessage",
      teamId,
      text,
    });
  }

  sendTypingIndicator(teamId, isTyping) {
    this.sendMessage({
      type: "team.typing",
      teamId,
      isTyping,
    });
  }

  markNotificationsRead(notificationIds) {
    this.sendMessage({
      type: "notifications.markRead",
      notificationIds,
    });
  }

  subscribeToHackathon(hackathonId) {
    this.sendMessage({
      type: "hackathon.subscribe",
      hackathonId,
    });
  }
}

// Singleton instance
let webSocketServiceInstance = null;

export const getWebSocketService = (store) => {
  if (!webSocketServiceInstance) {
    webSocketServiceInstance = new WebSocketService(store);
  }
  return webSocketServiceInstance;
};

export const initWebSocketService = (store) => {
  return getWebSocketService(store);
};

========== FILE END ==========


App.tsx 

import { Toaster } from "@/components/ui/toaster";
import { Toaster as Sonner } from "@/components/ui/sonner";
import { TooltipProvider } from "@/components/ui/tooltip";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { Provider } from 'react-redux';
import { store } from './store/index';
import { useAuth } from './store/hooks';
import { verifyToken } from './store/slices/authSlice';
import { ThemeProvider } from "@/components/theme/theme-provider";
import { Navbar } from "@/components/layout/navbar";
import { Footer } from "@/components/layout/footer";
import Landing from "./pages/Landing";
import Login from "./pages/Login";
import Signup from "./pages/Signup";
import Dashboard from "./pages/Dashboard";
import Lobbies from "./pages/Lobbies";
import Teams from "./pages/Teams";
import Profile from "./pages/Profile";
import Analytics from "./pages/Analytics";
import Settings from "./pages/Settings";
import NotFound from "./pages/NotFound";
import { useEffect } from "react";
import { LoadingSpinner } from "./components/utils/LoadingSpinner";

// WebSocket integration
import { webSocketService } from './store/index';
import { useWebSocket } from './hooks/websocketHooks';

const queryClient = new QueryClient();

// WebSocket connection manager component
const WebSocketManager = () => {
  const { isAuthenticated, user } = useAuth();
  const { isConnected, error, clearWebSocketError } = useWebSocket();

  useEffect(() => {
    // Connect to WebSocket when authenticated
    if (isAuthenticated && user?.token) {
      webSocketService.connect(user.token);
    } else {
      // Disconnect when not authenticated
      webSocketService.disconnect();
    }

    return () => {
      // Cleanup on unmount
      webSocketService.disconnect();
    };
  }, [isAuthenticated, user?.token]);

  // Handle network status changes
  useEffect(() => {
    const handleOnline = () => {
      if (isAuthenticated && user?.token && !isConnected) {
        webSocketService.connect(user.token);
      }
    };

    const handleOffline = () => {
      webSocketService.disconnect();
    };

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, [isAuthenticated, user?.token, isConnected]);

  return <></>;
};

const AppContent: React.FC = () => {
  const { isAuthenticated, isLoading, dispatch,message } = useAuth();
  
  useEffect(() => {
    const token = localStorage.getItem('token');
    if (token && !isAuthenticated) {
      dispatch(verifyToken());
    }
  }, [dispatch, isAuthenticated]);

  // if (isLoading) {
  //   return (
  //     <div className="min-h-screen bg-background flex items-center justify-center">
  //       <LoadingSpinner size="lg" />
  //     </div>
  //   );
  // }

  return (
    <QueryClientProvider client={queryClient}>
      <ThemeProvider defaultTheme="dark" storageKey="hackmate-ui-theme">
        <TooltipProvider>
          <Toaster />
          <Sonner />
          
          {/* WebSocket Manager */}
          <WebSocketManager />
          
          <Router>
            <div className="min-h-screen bg-background text-foreground">
              <Navbar />
              <main className="pt-20">
                <Routes>
                  <Route path="/" element={<Landing />} />
                  <Route path="/login" element={<Login />} />
                  <Route path="/signup" element={<Signup />} />
                  <Route 
                    path="/dashboard" 
                    element={isAuthenticated ? <Dashboard /> : <Navigate to="/login" />} 
                  />
                  <Route 
                    path="/lobbies" 
                    element={isAuthenticated ? <Lobbies /> : <Navigate to="/login" />} 
                  />
                  <Route 
                    path="/teams" 
                    element={isAuthenticated ? <Teams /> : <Navigate to="/login" />} 
                  />
                  <Route 
                    path="/analytics" 
                    element={isAuthenticated ? <Analytics /> : <Navigate to="/login" />} 
                  />
                  <Route 
                    path="/profile" 
                    element={isAuthenticated ? <Profile /> : <Navigate to="/login" />} 
                  />
                  <Route 
                    path="/settings" 
                    element={isAuthenticated ? <Settings /> : <Navigate to="/login" />} 
                  />
                  {/* ADD ALL CUSTOM ROUTES ABOVE THE CATCH-ALL "*" ROUTE */}
                  <Route path="*" element={<NotFound />} />
                </Routes>
              </main>
              <Footer />
            </div>
          </Router>
        </TooltipProvider>
      </ThemeProvider>
    </QueryClientProvider>
  );
};

const App: React.FC = () => {
  return (
    <Provider store={store}>
      <AppContent />
    </Provider>
  );
};

export default App;